# Copyright (C) 2025 Greenbone AG
#
# SPDX-License-Identifier: GPL-3.0-or-later

from collections.abc import Mapping
from typing import Any, Dict, Iterable, Set

from pontos.csaf import ProductStatus, Remediation


class Vulnerability(Mapping):
    def __init__(self, vulnerability: dict[str, Any]):
        self._data = vulnerability

    def __getitem__(self, key: str) -> Any:
        return self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    @property
    def cve(self) -> str:
        return self["cve"]

    @property
    def affected_product_ids(self) -> Set[str]:
        affected_keys = ProductStatus.all_confirmed_affected_keys()
        active_keys = affected_keys & set(self["product_status"].keys())
        if not active_keys:
            return set()
        affected_prods = set.union(
            *(set(self["product_status"][key]) for key in active_keys)
        )
        return affected_prods

    def iter_notes(self) -> Iterable[Dict[str, str]]:
        if "notes" not in self:
            return
        for note in self["notes"]:
            yield note

    def iter_remediations(self) -> Iterable[Dict[str, Any]]:
        if "remediations" not in self:
            return
        for remediation in self["remediations"]:
            yield remediation

    @property
    def confirmed_fixed_product_ids(self) -> Set[str]:
        res = set()
        for remediation in self.iter_remediations():
            # It's explicitly possible for multiple remediations
            # with the same category exist.
            # E.g., if multiple products are supported and how to upgrade them differs
            if remediation["category"] == Remediation.VENDOR_FIX:
                # Either Product ID or Group ID
                res |= set(remediation["product_ids"])

        fixed_keys = ProductStatus.all_explicitly_fixed_keys()
        active_keys = fixed_keys & set(self["product_status"].keys())
        if active_keys:
            res |= set.union(
                *(set(self["product_status"][key]) for key in active_keys)
            )
        return res
